import { getClients, getServerConfig } from '../utils/database'
import { execSync } from 'child_process'

export default defineNitroPlugin(async (nitroApp) => {
    nitroApp.hooks.hook('request', () => {
        // No-op for requests
    })

    // Run sync on startup
    console.log('üîÑ WireGuard Sync: Starting...')
    await syncWireGuardPeers()
})

async function syncWireGuardPeers() {
    try {
        const clients = getClients()
        const serverConfig = getServerConfig()

        if (!serverConfig) {
            console.warn('‚ö†Ô∏è WireGuard Sync: Server config not found, skipping.')
            return
        }

        console.log(`üîÑ WireGuard Sync: Found ${clients.length} clients in database.`)

        // 1. Ensure Interface is up (basic check)
        try {
            execSync('wg show wg0', { stdio: 'ignore' })
        } catch {
            console.log('‚ö†Ô∏è WireGuard interface wg0 not found. Attempting to initialize...')
            // In a managed container, we assume wg0 is handled by supervisor, 
            // but we can try basic setup if needed or just log warning.
            // For now, if wg0 is down, we probably can't do much without full wg-quick context
            return
        }

        // 2. Add each peer to interface
        const peersConfig: string[] = []
        let synced = 0
        for (const client of clients) {
            if (client.enabled && client.public_key) {
                try {
                    // Runtime Sync
                    // Command to add peer. If peer exists, it updates it.
                    // wg set wg0 peer <KEY> allowed-ips <IPS>
                    execSync(`wg set wg0 peer "${client.public_key}" allowed-ips "${client.allocated_ips.join(',')}"`, { stdio: 'ignore' })
                    synced++

                    // Config Gen
                    const presharedKeyLine = client.preshared_key ? `PresharedKey = ${client.preshared_key}\n` : ''
                    peersConfig.push(`
[Peer]
# Client: ${client.name} (${client.id})
PublicKey = ${client.public_key}
${presharedKeyLine}AllowedIPs = ${client.allocated_ips.join(',')}
`)
                } catch (e) {
                    console.error(`‚ùå Failed to sync peer ${client.name} (${client.id}):`, e)
                }
            }
        }
        console.log(`‚úÖ WireGuard Sync: Synced ${synced}/${clients.length} peers to wg0 interface.`)

        // 3. Write wg0.conf to disk (For container persistence and PostUp rules)
        try {
            const fs = await import('fs')
            const path = await import('path')

            // Default PostUp/Down if missing
            const postUp = serverConfig.post_up || 'iptables -A FORWARD -i wg0 -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE'
            const postDown = serverConfig.post_down || 'iptables -D FORWARD -i wg0 -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE'

            const wgConfigContent = `
# Auto-generated by SecDash
[Interface]
Address = ${serverConfig.addresses.join(',')}
ListenPort = ${serverConfig.listen_port}
PrivateKey = ${serverConfig.private_key}
PostUp = ${postUp}
PostDown = ${postDown}

${peersConfig.join('\n')}
`
            const configPath = '/etc/wireguard/wg0.conf'
            await fs.promises.mkdir(path.dirname(configPath), { recursive: true })
            await fs.promises.writeFile(configPath, wgConfigContent)
            console.log(`‚úÖ Config Saved: Wrote full configuration to ${configPath}`)

        } catch (e) {
            console.error('‚ùå Failed to write wg0.conf:', e)
        }

        // 4. Ensure NAT/Masquerade Rules (Runtime safety)
        try {
            // Check if rule exists before adding (simple heuristic)
            // Just attempting to add them (idempotent if we checked, but blindly adding duplicates is bad).
            // Better: flush and re-add or just add-if-not-exists.

            // Cleanest way for this startup script:
            // 1. Allow Forwarding from wg0
            execSync('iptables -C FORWARD -i wg0 -j ACCEPT || iptables -A FORWARD -i wg0 -j ACCEPT', { stdio: 'ignore' })

            // 2. Masquerade (NAT) on default route interface (usually eth0)
            // We assume eth0 for Docker environment.
            execSync('iptables -t nat -C POSTROUTING -o eth0 -j MASQUERADE || iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE', { stdio: 'ignore' })

        } catch (e) {
            // ignore
        }

    } catch (err) {
        console.error('‚ùå WireGuard Sync Fatal Error:', err)
    }
}
